import warnings

import matplotlib.pyplot as plt
import numpy as np
import polars as pl
import seaborn as sns
from anndata import AnnData
from matplotlib.axes import Axes
from mudata import MuData
from scipy.stats import gaussian_kde

from .. import tools
from ..utils import _get_fragment_key


def tss_enrichment(
    data: AnnData,
    color: str | None = None,
    title: str = "TSS Enrichment",
    ax: Axes | None = None,
):
    """
    Plot relative enrichment scores around a TSS.

    Parameters
    ----------
    data
        AnnData object with cell x TSS_position matrix as generated by `muon.atac.tl.tss_enrichment`.
    color
        Column name of .obs slot of the AnnData object which to group TSS signals by.
    title
        Plot title.
    ax
        A matplotlib axes object.
    """
    ax = ax or plt.gca()

    if color is not None:
        if isinstance(color, str):
            color = [color]

        groups = data.obs.groupby(color)

        for name, group in groups:
            ad = data[group.index]
            _tss_enrichment_single(ad, ax, label=name)
    else:
        _tss_enrichment_single(data, ax)

    # TODO: Fix plot returning/showing
    ax.set_title(title)
    ax.set_xlabel("Distance from TSS, bp")
    ax.set_ylabel("Average TSS enrichment score")
    if color:
        ax.legend(loc="upper right", title=", ".join(color))
    plt.show()
    return None


def _tss_enrichment_single(data: AnnData, ax: Axes, sd: bool = False, *args, **kwargs):
    x = data.var["TSS_position"]
    means = data.X.mean(axis=0)
    ax.plot(x, means, **kwargs)
    if sd:
        sd = np.sqrt(data.X.var(axis=0))
        plt.fill_between(
            x,
            means - sd,
            means + sd,
            alpha=0.2,
        )


def histogram(
    data: AnnData | MuData,
    region: str = "chr1-1-2000000",
    groupby: str | None = None,
    barcodes: str | None = None,
    show: bool | None = None,
    save: str | bool | None = None,
):
    """
    Plot Histogram of Fragment lengths within specified region.
    Parameters
    ----------
    data
        AnnData object with peak counts or multimodal MuData object with 'atac' modality.
    region
        Region to plot. Specified with the format `chr1:1-2000000` or`chr1-1-2000000`.
    groupby
        Column name(s) of .obs slot of the AnnData object according to which the plot is split.
    barcodes
        Column name of .obs slot of the AnnData object
        with barcodes corresponding to the ones in the fragments file.
    show
        Show the plot, do not return axis.
    save
        If `True` or a `str`, save the figure.
        A string is appended to the default filename.
        Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.
    """
    from scanpy.plotting._utils import savefig_or_show

    if isinstance(data, AnnData):
        adata = data
    elif isinstance(data, MuData):
        adata = data.mod["atac"]
    else:
        raise TypeError("Expected AnnData or MuData object with 'atac' modality")

    fragment_path = adata.uns["files"]["fragments"]
    fragments = tools.fetch_in_regions(fragment_path=fragment_path, regions=region)

    # Calculate fragment lengths
    fragments = fragments.with_columns((pl.col("end") - pl.col("start")).alias("length"))

    # Get obs data as polars DataFrame
    if barcodes and barcodes in adata.obs.columns:
        obs_df = pl.from_pandas(adata.obs.reset_index().rename(columns={adata.obs.index.name or 'index': 'original_index'}))
        join_key = barcodes
    else:
        obs_df = pl.from_pandas(adata.obs.reset_index())
        join_key = adata.obs.index.name or 'index'

    # Join with obs data
    fragments = fragments.join(
        obs_df,
        left_on="name",
        right_on=join_key,
        how="inner"
    )

    # Handle sns.distplot deprecation and sns.histplot addition
    hist = sns.histplot if hasattr(sns, "histplot") else sns.distplot

    binwidth = 5
    if hasattr(sns, "histplot"):
        kwargs = {"binwidth": binwidth}
    else:
        n_bins = int(np.ceil(fragments['length'].max() / binwidth))
        kwargs = {"bins": n_bins, "kde": False}

    # Convert to pandas for seaborn plotting
    fragments_pd = fragments.to_pandas()

    if groupby is not None:
        if isinstance(groupby, str):
            groupby = [groupby]
        if len(groupby) > 2:
            raise ValueError("Maximum 2 categories in groupby")
        elif len(groupby) == 2:
            g = sns.FacetGrid(fragments_pd, col=groupby[0], row=groupby[1], sharey=False)
        elif len(groupby) == 1:
            g = sns.FacetGrid(fragments_pd, col=groupby[0], sharey=False)
        g.map(hist, "length", **kwargs)
        g.set_xlabels("Fragment length (bp)")
    else:
        g = hist(fragments_pd['length'].to_numpy(), **kwargs)
        g.set_xlabel("Fragment length (bp)")
    g.set(xlim=(0, 1000))

    savefig_or_show("fragment_histogram_", show=show, save=save)


def qc_scatter(
    data: AnnData | MuData,
    region: str | list[str] | None = None,
    in_peaks: bool = False,
    peaks_only: bool = False,
    barcodes: str | None = None,
    show: bool | None = None,
    save: str | bool | None = None,
    ax: Axes | None = None,
    figsize: tuple = (8, 6),
    cmap: str = "viridis",
    colorbar: bool = True,
    title: str = "Quality Control Scatter Plot",
    color_by_density: bool = True,
    unique: bool = True,
    cut_sites: bool = False,
    verbose: bool = True,
    fragment_key: str | None = None,
    **kwargs
):
    """
    Plot the number of unique fragments (log10) vs TSS enrichment score.
    
    Parameters
    ----------
    data
        AnnData object with peak counts or multimodal MuData object with 'atac' or 'peaks' modality.
    region
        Region or list of regions to count fragments in, in the format 'chr1' (entire chromosome) 
        or 'chr1:1-100000' or 'chr1-1-100000'. If None, count fragments in the entire genome.
    in_peaks
        Whether to count only fragments that overlap with peaks. 
        Requires var_names in adata to be in format 'chr:start-end'.
    peaks_only
        If True, only plot cells that have fragments in peaks. Only relevant when in_peaks=True.
    barcodes
        Column name of .obs slot of the AnnData object
        with barcodes corresponding to the ones in the fragments file.
    show
        Show the plot, do not return axis.
    save
        If `True` or a `str`, save the figure.
        A string is appended to the default filename.
        Infer the filetype if ending on {`'.pdf'`, `'.png'`, `'.svg'`}.
    ax
        A matplotlib axes object.
    figsize
        Figure size.
    cmap
        Colormap to use for the scatter plot.
    colorbar
        Whether to show a colorbar.
    title
        Plot title.
    color_by_density
        If True (default), color points by density. If False, color points by log10(fragments).
    unique
        If True, count each fragment only once per cell. If False, count fragments
        according to the score field in the fragments file (number of read pairs).
    cut_sites
        If True, count individual cut sites instead of fragments. Each fragment has 
        two cut sites (5' and 3' ends).
    verbose
        Whether to show progress bars when computing fragment counts.
    fragment_key
        If provided, use this key to access existing fragment counts in .obs.
        If None, construct a key based on the parameters.
    **kwargs
        Additional arguments passed to plt.scatter.
    
    Returns
    -------
    Axes
        The matplotlib axes object.
    """
    from scanpy.plotting._utils import savefig_or_show

    if isinstance(data, AnnData):
        adata = data
    elif isinstance(data, MuData) and "atac" in data.mod:
        adata = data.mod["atac"]
    elif isinstance(data, MuData) and "peaks" in data.mod:
        adata = data.mod["peaks"]
    else:
        raise TypeError("Expected AnnData or MuData object with 'atac' or 'peaks' modality")

    if "tss_score" not in adata.obs:
        raise ValueError("TSS enrichment score not found in .obs. Run tss_enrichment first.")

    if "files" not in adata.uns or "fragments" not in adata.uns["files"]:
        raise KeyError("No fragments file located. Run tools.locate_fragments first.")

    # Construct the fragment key if not provided
    if fragment_key is None:
        fragment_key = _get_fragment_key(unique, cut_sites, in_peaks, region)

    # Check if fragment counts need to be computed
    if fragment_key not in adata.obs.columns:
        from ..preproc import count_fragments

        # Compute fragment counts and add to .obs
        count_fragments(
            data,
            region=region,
            in_peaks=in_peaks,
            unique=unique,
            cut_sites=cut_sites,
            barcodes=barcodes,
            verbose=verbose,
            add_key=fragment_key
        )

    # Get fragment counts from data.obs
    fragment_counts = adata.obs[fragment_key]

    # Get the tss enrichment scores
    tss_scores = adata.obs["tss_score"]

    # Create the plot
    if ax is None:
        fig, ax = plt.subplots(figsize=figsize)

    # Filter for cells with fragments in peaks if required
    if in_peaks and peaks_only:
        mask = fragment_counts > 0
        fragment_counts = fragment_counts[mask]
        tss_scores = tss_scores[mask]

    # Log10 transform the fragment counts
    log10_counts = np.log10(fragment_counts + 1)

    # Prepare data for scatter plot
    data_array = np.vstack([log10_counts, tss_scores])

    # Create a title for the colorbar and x-axis
    if cut_sites:
        count_label = "log10(Cut Sites)"
    else:
        count_label = "log10(Unique Fragments)" if unique else "log10(Fragments)"

    # Color points by density or by fragment count
    if color_by_density and len(log10_counts) > 2:
        try:
            # Calculate the density of points using KDE
            kde = gaussian_kde(data_array)
            density = kde(data_array)

            # Sort points by density so that denser points are plotted last (on top)
            idx = density.argsort()
            x, y, density = log10_counts.iloc[idx], tss_scores.iloc[idx], density[idx]

            # Create the scatter plot colored by density
            scatter = ax.scatter(
                x, y,
                c=density,
                cmap=cmap,
                alpha=0.7,
                **kwargs
            )

            # Add colorbar if requested
            if colorbar:
                cbar = plt.colorbar(scatter, ax=ax)
                cbar.set_label("Density")
        except (ValueError, np.linalg.LinAlgError):
            # Fallback to default coloring if KDE fails (e.g., with too few points)
            warnings.warn("Density estimation failed. Falling back to coloring by fragment count.")
            scatter = ax.scatter(
                log10_counts,
                tss_scores,
                c=log10_counts,
                cmap=cmap,
                alpha=0.7,
                **kwargs
            )

            # Add colorbar if requested
            if colorbar:
                cbar = plt.colorbar(scatter, ax=ax)
                cbar.set_label(count_label)
    else:
        # Create the scatter plot colored by fragment count
        scatter = ax.scatter(
            log10_counts,
            tss_scores,
            c=log10_counts,
            cmap=cmap,
            alpha=0.7,
            **kwargs
        )

        # Add colorbar if requested
        if colorbar:
            cbar = plt.colorbar(scatter, ax=ax)
            cbar.set_label(count_label)

    # Set axis labels and title
    ax.set_xlabel(count_label)
    ax.set_ylabel("TSS Enrichment Score")

    # Modify title if region is specified
    if region is not None:
        if isinstance(region, list):
            if len(region) == 1:
                region_str = region[0]
            else:
                region_str = f"{len(region)} regions"
        else:
            region_str = region
        title = f"{title} in {region_str}"

    ax.set_title(title)

    # Add grid lines
    ax.grid(True, linestyle='--', alpha=0.7)

    savefig_or_show("qc_scatter_", show=show, save=save)

    return ax
